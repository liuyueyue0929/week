{"version":3,"sources":["index-compiled.js"],"names":[],"mappings":"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","file":"index-compiled-compiled.js","sourcesContent":["/*!\n * type-is\n * Copyright(c) 2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict';\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar typer = require('media-typer');\nvar mime = require('mime-types'\n\n/**\n * Module exports.\n * @public\n */\n\n);module.exports = typeofrequest;\nmodule.exports.is = typeis;\nmodule.exports.hasBody = hasbody;\nmodule.exports.normalize = normalize;\nmodule.exports.match = mimeMatch;\n\n/**\n * Compare a `value` content-type with `types`.\n * Each `type` can be an extension like `html`,\n * a special shortcut like `multipart` or `urlencoded`,\n * or a mime type.\n *\n * If no types match, `false` is returned.\n * Otherwise, the first `type` that matches is returned.\n *\n * @param {String} value\n * @param {Array} types\n * @public\n */\n\nfunction typeis(value, types_) {\n  var i;\n  var types = types_;\n\n  // remove parameters and normalize\n  var val = tryNormalizeType(value\n\n  // no type or invalid\n  );if (!val) {\n    return false;\n  }\n\n  // support flattened arguments\n  if (types && !Array.isArray(types)) {\n    types = new Array(arguments.length - 1);\n    for (i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1];\n    }\n  }\n\n  // no types, return the content type\n  if (!types || !types.length) {\n    return val;\n  }\n\n  var type;\n  for (i = 0; i < types.length; i++) {\n    if (mimeMatch(normalize(type = types[i]), val)) {\n      return type[0] === '+' || type.indexOf('*') !== -1 ? val : type;\n    }\n  }\n\n  // no matches\n  return false;\n}\n\n/**\n * Check if a request has a request body.\n * A request with a body __must__ either have `transfer-encoding`\n * or `content-length` headers set.\n * http://www.w3.org/Protocols/rfc2616/rfc2616-sec4.html#sec4.3\n *\n * @param {Object} request\n * @return {Boolean}\n * @public\n */\n\nfunction hasbody(req) {\n  return req.headers['transfer-encoding'] !== undefined || !isNaN(req.headers['content-length']);\n}\n\n/**\n * Check if the incoming request contains the \"Content-Type\"\n * header field, and it contains any of the give mime `type`s.\n * If there is no request body, `null` is returned.\n * If there is no content type, `false` is returned.\n * Otherwise, it returns the first `type` that matches.\n *\n * Examples:\n *\n *     // With Content-Type: text/html; charset=utf-8\n *     this.is('html'); // => 'html'\n *     this.is('text/html'); // => 'text/html'\n *     this.is('text/*', 'application/json'); // => 'text/html'\n *\n *     // When Content-Type is application/json\n *     this.is('json', 'urlencoded'); // => 'json'\n *     this.is('application/json'); // => 'application/json'\n *     this.is('html', 'application/*'); // => 'application/json'\n *\n *     this.is('html'); // => false\n *\n * @param {String|Array} types...\n * @return {String|false|null}\n * @public\n */\n\nfunction typeofrequest(req, types_) {\n  var types = types_;\n\n  // no body\n  if (!hasbody(req)) {\n    return null;\n  }\n\n  // support flattened arguments\n  if (arguments.length > 2) {\n    types = new Array(arguments.length - 1);\n    for (var i = 0; i < types.length; i++) {\n      types[i] = arguments[i + 1];\n    }\n  }\n\n  // request content type\n  var value = req.headers['content-type'];\n\n  return typeis(value, types);\n}\n\n/**\n * Normalize a mime type.\n * If it's a shorthand, expand it to a valid mime type.\n *\n * In general, you probably want:\n *\n *   var type = is(req, ['urlencoded', 'json', 'multipart']);\n *\n * Then use the appropriate body parsers.\n * These three are the most common request body types\n * and are thus ensured to work.\n *\n * @param {String} type\n * @private\n */\n\nfunction normalize(type) {\n  if (typeof type !== 'string') {\n    // invalid type\n    return false;\n  }\n\n  switch (type) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded';\n    case 'multipart':\n      return 'multipart/*';\n  }\n\n  if (type[0] === '+') {\n    // \"+json\" -> \"*/*+json\" expando\n    return '*/*' + type;\n  }\n\n  return type.indexOf('/') === -1 ? mime.lookup(type) : type;\n}\n\n/**\n * Check if `expected` mime type\n * matches `actual` mime type with\n * wildcard and +suffix support.\n *\n * @param {String} expected\n * @param {String} actual\n * @return {Boolean}\n * @private\n */\n\nfunction mimeMatch(expected, actual) {\n  // invalid type\n  if (expected === false) {\n    return false;\n  }\n\n  // split types\n  var actualParts = actual.split('/');\n  var expectedParts = expected.split('/'\n\n  // invalid format\n  );if (actualParts.length !== 2 || expectedParts.length !== 2) {\n    return false;\n  }\n\n  // validate type\n  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) {\n    return false;\n  }\n\n  // validate suffix wildcard\n  if (expectedParts[1].substr(0, 2) === '*+') {\n    return expectedParts[1].length <= actualParts[1].length + 1 && expectedParts[1].substr(1) === actualParts[1].substr(1 - expectedParts[1].length);\n  }\n\n  // validate subtype\n  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) {\n    return false;\n  }\n\n  return true;\n}\n\n/**\n * Normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction normalizeType(value) {\n  // parse the type\n  var type = typer.parse(value\n\n  // remove the parameters\n  );type.parameters = undefined;\n\n  // reformat it\n  return typer.format(type);\n}\n\n/**\n * Try to normalize a type and remove parameters.\n *\n * @param {string} value\n * @return {string}\n * @private\n */\n\nfunction tryNormalizeType(value) {\n  try {\n    return normalizeType(value);\n  } catch (err) {\n    return null;\n  }\n}\n\n//# sourceMappingURL=index-compiled.js.map"]}