{"version":3,"sources":["index.js"],"names":[],"mappings":"AAAA;;;;;;;AAOA;;AAEA;;;;;AAKA,IAAI,QAAQ,QAAQ,OAAR,CAAZ;AACA,IAAI,QAAQ,QAAQ,YAAR,CAAZ;AACA,IAAI,SAAS,QAAQ;;AAErB;;;;;AAFa,CAAb,CAOA,OAAO,OAAP,GAAiB,UAAjB;;AAEA;;;;;AAKA,IAAI,6BAA6B,4BAAjC;;AAEA;;;;;;;AAOA,SAAS,UAAT,CAAqB,QAArB,EAA+B;AAC7B,MAAI,CAAC,QAAL,EAAe,OAAO,IAAP;;AAEf,MAAI;AACF,WAAO,MAAM,UAAN,CAAiB,QAAjB,CAAP;AACD,GAFD,CAEE,OAAO,CAAP,EAAU;AACV;AACA,QAAI,CAAC,2BAA2B,IAA3B,CAAgC,EAAE,OAAlC,CAAL,EAAiD,MAAM,CAAN;;AAEjD;AACA,UAAM,YAAY,GAAZ,EAAiB,gCAAjB,EAAmD,sBAAnD,EAA2E;AAC/E,gBAAU;AADqE,KAA3E,CAAN;AAGD;AACF;;AAED;;;;;;;;;AASA,SAAS,UAAT,CAAqB,MAArB,EAA6B,OAA7B,EAAsC,QAAtC,EAAgD;AAC9C,MAAI,OAAO,QAAX;AACA,MAAI,OAAO,WAAW,EAAtB;;AAEA,MAAI,YAAY,IAAZ,IAAoB,OAAO,OAAP,KAAmB,QAA3C,EAAqD;AACnD;AACA,WAAO;AACL,gBAAU;AADL,KAAP;AAGD;;AAED,MAAI,OAAO,OAAP,KAAmB,UAAvB,EAAmC;AACjC,WAAO,OAAP;AACA,WAAO,EAAP;AACD;;AAED;AACA,MAAI,SAAS,SAAT,IAAsB,OAAO,IAAP,KAAgB,UAA1C,EAAsD;AACpD,UAAM,IAAI,SAAJ,CAAc,sCAAd,CAAN;AACD;;AAED;AACA,MAAI,CAAC,IAAD,IAAS,CAAC,OAAO,OAArB,EAA8B;AAC5B,UAAM,IAAI,SAAJ,CAAc,+BAAd,CAAN;AACD;;AAED;AACA,MAAI,WAAW,KAAK,QAAL,KAAkB,IAAlB,GACX,KAAK,QADM,GAEX,OAFJ;;AAIA;AACA,MAAI,QAAQ,MAAM,KAAN,CAAY,KAAK;;AAE7B;AAFY,GAAZ,CAGA,IAAI,SAAS,KAAK,MAAL,IAAe,IAAf,IAAuB,CAAC,MAAM,KAAK,MAAX,CAAxB,GACT,SAAS,KAAK,MAAd,EAAsB,EAAtB,CADS,GAET,IAFJ;;AAIA,MAAI,IAAJ,EAAU;AACR;AACA,WAAO,WAAW,MAAX,EAAmB,QAAnB,EAA6B,MAA7B,EAAqC,KAArC,EAA4C,IAA5C,CAAP;AACD;;AAED,SAAO,IAAI,OAAJ,CAAY,SAAS,QAAT,CAAmB,OAAnB,EAA4B,MAA5B,EAAoC;AACrD,eAAW,MAAX,EAAmB,QAAnB,EAA6B,MAA7B,EAAqC,KAArC,EAA4C,SAAS,MAAT,CAAiB,GAAjB,EAAsB,GAAtB,EAA2B;AACrE,UAAI,GAAJ,EAAS,OAAO,OAAO,GAAP,CAAP;AACT,cAAQ,GAAR;AACD,KAHD;AAID,GALM,CAAP;AAMD;;AAED;;;;;;;AAOA,SAAS,IAAT,CAAe,MAAf,EAAuB;AACrB;AACA,SAAO;;AAEP;AAFA,IAGA,IAAI,OAAO,OAAO,KAAd,KAAwB,UAA5B,EAAwC;AACtC,WAAO,KAAP;AACD;AACF;;AAED;;;;;;;;;;;;;;AAcA,SAAS,WAAT,CAAsB,MAAtB,EAA8B,OAA9B,EAAuC,IAAvC,EAA6C,KAA7C,EAAoD;AAClD,MAAI,QAAQ,IAAI,KAAJ,EAAZ;;AAEA;AACA,QAAM,iBAAN,CAAwB,KAAxB,EAA+B;;AAE/B;AAFA,IAGA,KAAK,IAAI,IAAT,IAAiB,KAAjB,EAAwB;AACtB,UAAM,IAAN,IAAc,MAAM,IAAN,CAAd;AACD;;AAED;AACA,QAAM,OAAN,GAAgB,OAAhB;;AAEA;AACA,QAAM,MAAN,GAAe,MAAf;AACA,QAAM,UAAN,GAAmB,MAAnB;;AAEA;AACA,SAAO,cAAP,CAAsB,KAAtB,EAA6B,MAA7B,EAAqC;AACnC,WAAO,IAD4B;AAEnC,gBAAY,IAFuB;AAGnC,cAAU,IAHyB;AAInC,kBAAc;AAJqB,GAArC;;AAOA,SAAO,KAAP;AACD;;AAED;;;;;;;;;;;AAWA,SAAS,UAAT,CAAqB,MAArB,EAA6B,QAA7B,EAAuC,MAAvC,EAA+C,KAA/C,EAAsD,QAAtD,EAAgE;AAC9D,MAAI,WAAW,KAAf;AACA,MAAI,OAAO,IAAX;;AAEA;AACA;AACA;AACA,MAAI,UAAU,IAAV,IAAkB,WAAW,IAA7B,IAAqC,SAAS,KAAlD,EAAyD;AACvD,WAAO,KAAK,YAAY,GAAZ,EAAiB,0BAAjB,EAA6C,kBAA7C,EAAiE;AAC3E,gBAAU,MADiE;AAE3E,cAAQ,MAFmE;AAG3E,aAAO;AAHoE,KAAjE,CAAL,CAAP;AAKD;;AAED;AACA;AACA;AACA;AACA;AACA,MAAI,QAAQ,OAAO,cAAnB;AACA,MAAI,OAAO,QAAP,IAAoB,UAAU,MAAM,QAAN,IAAkB,MAAM,OAAlC,CAAxB,EAAqE;AACnE;AACA,WAAO,KAAK,YAAY,GAAZ,EAAiB,mCAAjB,EAAsD,qBAAtD,CAAL,CAAP;AACD;;AAED,MAAI,WAAW,CAAf;AACA,MAAI,OAAJ;;AAEA,MAAI;AACF,cAAU,WAAW,QAAX,CAAV;AACD,GAFD,CAEE,OAAO,GAAP,EAAY;AACZ,WAAO,KAAK,GAAL,CAAP;AACD;;AAED,MAAI,SAAS,UACT,EADS,GAET,EAFJ;;AAIA;AACA,SAAO,EAAP,CAAU,SAAV,EAAqB,SAArB;AACA,SAAO,EAAP,CAAU,OAAV,EAAmB,OAAnB;AACA,SAAO,EAAP,CAAU,MAAV,EAAkB,MAAlB;AACA,SAAO,EAAP,CAAU,KAAV,EAAiB,KAAjB;AACA,SAAO,EAAP,CAAU,OAAV,EAAmB;;AAEnB;AAFA,IAGA,OAAO,KAAP;;AAEA,WAAS,IAAT,GAAiB;AACf,QAAI,OAAO,IAAI,KAAJ,CAAU,UAAU,MAApB,CAAX;;AAEA;AACA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,KAAK,MAAzB,EAAiC,GAAjC,EAAsC;AACpC,WAAK,CAAL,IAAU,UAAU,CAAV,CAAV;AACD;;AAED;AACA,eAAW,IAAX;;AAEA,QAAI,IAAJ,EAAU;AACR,cAAQ,QAAR,CAAiB,cAAjB;AACD,KAFD,MAEO;AACL;AACD;;AAED,aAAS,cAAT,GAA2B;AACzB;;AAEA,UAAI,KAAK,CAAL,CAAJ,EAAa;AACX;AACA,aAAK,MAAL;AACD;;AAED,eAAS,KAAT,CAAe,IAAf,EAAqB,IAArB;AACD;AACF;;AAED,WAAS,SAAT,GAAsB;AACpB,QAAI,QAAJ,EAAc;;AAEd,SAAK,YAAY,GAAZ,EAAiB,iBAAjB,EAAoC,iBAApC,EAAuD;AAC1D,YAAM,cADoD;AAE1D,gBAAU,MAFgD;AAG1D,cAAQ,MAHkD;AAI1D,gBAAU;AAJgD,KAAvD,CAAL;AAMD;;AAED,WAAS,MAAT,CAAiB,KAAjB,EAAwB;AACtB,QAAI,QAAJ,EAAc;;AAEd,gBAAY,MAAM,MAAlB;AACA,cACI,UAAU,QAAQ,KAAR,CAAc,KAAd,CADd,GAEI,OAAO,IAAP,CAAY,KAAZ,CAFJ;;AAIA,QAAI,UAAU,IAAV,IAAkB,WAAW,KAAjC,EAAwC;AACtC,WAAK,YAAY,GAAZ,EAAiB,0BAAjB,EAA6C,kBAA7C,EAAiE;AACpE,eAAO,KAD6D;AAEpE,kBAAU;AAF0D,OAAjE,CAAL;AAID;AACF;;AAED,WAAS,KAAT,CAAgB,GAAhB,EAAqB;AACnB,QAAI,QAAJ,EAAc;AACd,QAAI,GAAJ,EAAS,OAAO,KAAK,GAAL,CAAP;;AAET,QAAI,WAAW,IAAX,IAAmB,aAAa,MAApC,EAA4C;AAC1C,WAAK,YAAY,GAAZ,EAAiB,2CAAjB,EAA8D,sBAA9D,EAAsF;AACzF,kBAAU,MAD+E;AAEzF,gBAAQ,MAFiF;AAGzF,kBAAU;AAH+E,OAAtF,CAAL;AAKD,KAND,MAMO;AACL,UAAI,SAAS,UACT,UAAU,QAAQ,GAAR,MAAiB,EAA3B,CADS,GAET,OAAO,MAAP,CAAc,MAAd,CAFJ;AAGA,WAAK,IAAL,EAAW,MAAX;AACD;AACF;;AAED,WAAS,OAAT,GAAoB;AAClB,aAAS,IAAT;;AAEA,WAAO,cAAP,CAAsB,SAAtB,EAAiC,SAAjC;AACA,WAAO,cAAP,CAAsB,MAAtB,EAA8B,MAA9B;AACA,WAAO,cAAP,CAAsB,KAAtB,EAA6B,KAA7B;AACA,WAAO,cAAP,CAAsB,OAAtB,EAA+B,KAA/B;AACA,WAAO,cAAP,CAAsB,OAAtB,EAA+B,OAA/B;AACD;AACF","file":"index-compiled.js","sourcesContent":["/*!\n * raw-body\n * Copyright(c) 2013-2014 Jonathan Ong\n * Copyright(c) 2014-2015 Douglas Christopher Wilson\n * MIT Licensed\n */\n\n'use strict'\n\n/**\n * Module dependencies.\n * @private\n */\n\nvar bytes = require('bytes')\nvar iconv = require('iconv-lite')\nvar unpipe = require('unpipe')\n\n/**\n * Module exports.\n * @public\n */\n\nmodule.exports = getRawBody\n\n/**\n * Module variables.\n * @private\n */\n\nvar iconvEncodingMessageRegExp = /^Encoding not recognized: /\n\n/**\n * Get the decoder for a given encoding.\n *\n * @param {string} encoding\n * @private\n */\n\nfunction getDecoder (encoding) {\n  if (!encoding) return null\n\n  try {\n    return iconv.getDecoder(encoding)\n  } catch (e) {\n    // error getting decoder\n    if (!iconvEncodingMessageRegExp.test(e.message)) throw e\n\n    // the encoding was not found\n    throw createError(415, 'specified encoding unsupported', 'encoding.unsupported', {\n      encoding: encoding\n    })\n  }\n}\n\n/**\n * Get the raw body of a stream (typically HTTP).\n *\n * @param {object} stream\n * @param {object|string|function} [options]\n * @param {function} [callback]\n * @public\n */\n\nfunction getRawBody (stream, options, callback) {\n  var done = callback\n  var opts = options || {}\n\n  if (options === true || typeof options === 'string') {\n    // short cut for encoding\n    opts = {\n      encoding: options\n    }\n  }\n\n  if (typeof options === 'function') {\n    done = options\n    opts = {}\n  }\n\n  // validate callback is a function, if provided\n  if (done !== undefined && typeof done !== 'function') {\n    throw new TypeError('argument callback must be a function')\n  }\n\n  // require the callback without promises\n  if (!done && !global.Promise) {\n    throw new TypeError('argument callback is required')\n  }\n\n  // get encoding\n  var encoding = opts.encoding !== true\n    ? opts.encoding\n    : 'utf-8'\n\n  // convert the limit to an integer\n  var limit = bytes.parse(opts.limit)\n\n  // convert the expected length to an integer\n  var length = opts.length != null && !isNaN(opts.length)\n    ? parseInt(opts.length, 10)\n    : null\n\n  if (done) {\n    // classic callback style\n    return readStream(stream, encoding, length, limit, done)\n  }\n\n  return new Promise(function executor (resolve, reject) {\n    readStream(stream, encoding, length, limit, function onRead (err, buf) {\n      if (err) return reject(err)\n      resolve(buf)\n    })\n  })\n}\n\n/**\n * Halt a stream.\n *\n * @param {Object} stream\n * @private\n */\n\nfunction halt (stream) {\n  // unpipe everything from the stream\n  unpipe(stream)\n\n  // pause stream\n  if (typeof stream.pause === 'function') {\n    stream.pause()\n  }\n}\n\n/**\n * Make a serializable error object.\n *\n * To create serializable errors you must re-set message so\n * that it is enumerable and you must re configure the type\n * property so that is writable and enumerable.\n *\n * @param {number} status\n * @param {string} message\n * @param {string} type\n * @param {object} props\n * @private\n */\n\nfunction createError (status, message, type, props) {\n  var error = new Error()\n\n  // capture stack trace\n  Error.captureStackTrace(error, createError)\n\n  // set free-form properties\n  for (var prop in props) {\n    error[prop] = props[prop]\n  }\n\n  // set message\n  error.message = message\n\n  // set status\n  error.status = status\n  error.statusCode = status\n\n  // set type\n  Object.defineProperty(error, 'type', {\n    value: type,\n    enumerable: true,\n    writable: true,\n    configurable: true\n  })\n\n  return error\n}\n\n/**\n * Read the data from the stream.\n *\n * @param {object} stream\n * @param {string} encoding\n * @param {number} length\n * @param {number} limit\n * @param {function} callback\n * @public\n */\n\nfunction readStream (stream, encoding, length, limit, callback) {\n  var complete = false\n  var sync = true\n\n  // check the length and limit options.\n  // note: we intentionally leave the stream paused,\n  // so users should handle the stream themselves.\n  if (limit !== null && length !== null && length > limit) {\n    return done(createError(413, 'request entity too large', 'entity.too.large', {\n      expected: length,\n      length: length,\n      limit: limit\n    }))\n  }\n\n  // streams1: assert request encoding is buffer.\n  // streams2+: assert the stream encoding is buffer.\n  //   stream._decoder: streams1\n  //   state.encoding: streams2\n  //   state.decoder: streams2, specifically < 0.10.6\n  var state = stream._readableState\n  if (stream._decoder || (state && (state.encoding || state.decoder))) {\n    // developer error\n    return done(createError(500, 'stream encoding should not be set', 'stream.encoding.set'))\n  }\n\n  var received = 0\n  var decoder\n\n  try {\n    decoder = getDecoder(encoding)\n  } catch (err) {\n    return done(err)\n  }\n\n  var buffer = decoder\n    ? ''\n    : []\n\n  // attach listeners\n  stream.on('aborted', onAborted)\n  stream.on('close', cleanup)\n  stream.on('data', onData)\n  stream.on('end', onEnd)\n  stream.on('error', onEnd)\n\n  // mark sync section complete\n  sync = false\n\n  function done () {\n    var args = new Array(arguments.length)\n\n    // copy arguments\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n\n    // mark complete\n    complete = true\n\n    if (sync) {\n      process.nextTick(invokeCallback)\n    } else {\n      invokeCallback()\n    }\n\n    function invokeCallback () {\n      cleanup()\n\n      if (args[0]) {\n        // halt the stream on error\n        halt(stream)\n      }\n\n      callback.apply(null, args)\n    }\n  }\n\n  function onAborted () {\n    if (complete) return\n\n    done(createError(400, 'request aborted', 'request.aborted', {\n      code: 'ECONNABORTED',\n      expected: length,\n      length: length,\n      received: received\n    }))\n  }\n\n  function onData (chunk) {\n    if (complete) return\n\n    received += chunk.length\n    decoder\n      ? buffer += decoder.write(chunk)\n      : buffer.push(chunk)\n\n    if (limit !== null && received > limit) {\n      done(createError(413, 'request entity too large', 'entity.too.large', {\n        limit: limit,\n        received: received\n      }))\n    }\n  }\n\n  function onEnd (err) {\n    if (complete) return\n    if (err) return done(err)\n\n    if (length !== null && received !== length) {\n      done(createError(400, 'request size did not match content length', 'request.size.invalid', {\n        expected: length,\n        length: length,\n        received: received\n      }))\n    } else {\n      var string = decoder\n        ? buffer + (decoder.end() || '')\n        : Buffer.concat(buffer)\n      done(null, string)\n    }\n  }\n\n  function cleanup () {\n    buffer = null\n\n    stream.removeListener('aborted', onAborted)\n    stream.removeListener('data', onData)\n    stream.removeListener('end', onEnd)\n    stream.removeListener('error', onEnd)\n    stream.removeListener('close', cleanup)\n  }\n}\n"]}