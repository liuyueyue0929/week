{"version":3,"sources":["sbcs-codec.js"],"names":[],"mappings":"AAAA;;AAEA;AACA;;AAEA,QAAQ,KAAR,GAAgB,SAAhB;AACA,SAAS,SAAT,CAAmB,YAAnB,EAAiC,KAAjC,EAAwC;AACpC,QAAI,CAAC,YAAL,EACI,MAAM,IAAI,KAAJ,CAAU,wCAAV,CAAN;;AAEJ;AACA,QAAI,CAAC,aAAa,KAAd,IAAwB,aAAa,KAAb,CAAmB,MAAnB,KAA8B,GAA9B,IAAqC,aAAa,KAAb,CAAmB,MAAnB,KAA8B,GAA/F,EACI,MAAM,IAAI,KAAJ,CAAU,eAAa,aAAa,IAA1B,GAA+B,qDAAzC,CAAN;;AAEJ,QAAI,aAAa,KAAb,CAAmB,MAAnB,KAA8B,GAAlC,EAAuC;AACnC,YAAI,cAAc,EAAlB;AACA,aAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,GAApB,EAAyB,GAAzB,EACI,eAAe,OAAO,YAAP,CAAoB,CAApB,CAAf;AACJ,qBAAa,KAAb,GAAqB,cAAc,aAAa,KAAhD;AACH;;AAED,SAAK,SAAL,GAAiB,IAAI,MAAJ,CAAW,aAAa,KAAxB,EAA+B,MAA/B,CAAjB;;AAEA;AACA,QAAI,YAAY,IAAI,MAAJ,CAAW,KAAX,CAAhB;AACA,cAAU,IAAV,CAAe,MAAM,qBAAN,CAA4B,UAA5B,CAAuC,CAAvC,CAAf;;AAEA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,aAAa,KAAb,CAAmB,MAAvC,EAA+C,GAA/C,EACI,UAAU,aAAa,KAAb,CAAmB,UAAnB,CAA8B,CAA9B,CAAV,IAA8C,CAA9C;;AAEJ,SAAK,SAAL,GAAiB,SAAjB;AACH;;AAED,UAAU,SAAV,CAAoB,OAApB,GAA8B,WAA9B;AACA,UAAU,SAAV,CAAoB,OAApB,GAA8B,WAA9B;;AAGA,SAAS,WAAT,CAAqB,OAArB,EAA8B,KAA9B,EAAqC;AACjC,SAAK,SAAL,GAAiB,MAAM,SAAvB;AACH;;AAED,YAAY,SAAZ,CAAsB,KAAtB,GAA8B,UAAS,GAAT,EAAc;AACxC,QAAI,MAAM,IAAI,MAAJ,CAAW,IAAI,MAAf,CAAV;AACA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,IAAI,MAAxB,EAAgC,GAAhC,EACI,IAAI,CAAJ,IAAS,KAAK,SAAL,CAAe,IAAI,UAAJ,CAAe,CAAf,CAAf,CAAT;;AAEJ,WAAO,GAAP;AACH,CAND;;AAQA,YAAY,SAAZ,CAAsB,GAAtB,GAA4B,YAAW,CACtC,CADD;;AAIA,SAAS,WAAT,CAAqB,OAArB,EAA8B,KAA9B,EAAqC;AACjC,SAAK,SAAL,GAAiB,MAAM,SAAvB;AACH;;AAED,YAAY,SAAZ,CAAsB,KAAtB,GAA8B,UAAS,GAAT,EAAc;AACxC;AACA,QAAI,YAAY,KAAK,SAArB;AACA,QAAI,SAAS,IAAI,MAAJ,CAAW,IAAI,MAAJ,GAAW,CAAtB,CAAb;AACA,QAAI,OAAO,CAAX;AAAA,QAAc,OAAO,CAArB;AACA,SAAK,IAAI,IAAI,CAAb,EAAgB,IAAI,IAAI,MAAxB,EAAgC,GAAhC,EAAqC;AACjC,eAAO,IAAI,CAAJ,IAAO,CAAd,CAAiB,OAAO,IAAE,CAAT;AACjB,eAAO,IAAP,IAAe,UAAU,IAAV,CAAf;AACA,eAAO,OAAK,CAAZ,IAAiB,UAAU,OAAK,CAAf,CAAjB;AACH;AACD,WAAO,OAAO,QAAP,CAAgB,MAAhB,CAAP;AACH,CAXD;;AAaA,YAAY,SAAZ,CAAsB,GAAtB,GAA4B,YAAW,CACtC,CADD","file":"sbcs-codec-compiled.js","sourcesContent":["\"use strict\"\n\n// Single-byte codec. Needs a 'chars' string parameter that contains 256 or 128 chars that\n// correspond to encoded bytes (if 128 - then lower half is ASCII). \n\nexports._sbcs = SBCSCodec;\nfunction SBCSCodec(codecOptions, iconv) {\n    if (!codecOptions)\n        throw new Error(\"SBCS codec is called without the data.\")\n    \n    // Prepare char buffer for decoding.\n    if (!codecOptions.chars || (codecOptions.chars.length !== 128 && codecOptions.chars.length !== 256))\n        throw new Error(\"Encoding '\"+codecOptions.type+\"' has incorrect 'chars' (must be of len 128 or 256)\");\n    \n    if (codecOptions.chars.length === 128) {\n        var asciiString = \"\";\n        for (var i = 0; i < 128; i++)\n            asciiString += String.fromCharCode(i);\n        codecOptions.chars = asciiString + codecOptions.chars;\n    }\n\n    this.decodeBuf = new Buffer(codecOptions.chars, 'ucs2');\n    \n    // Encoding buffer.\n    var encodeBuf = new Buffer(65536);\n    encodeBuf.fill(iconv.defaultCharSingleByte.charCodeAt(0));\n\n    for (var i = 0; i < codecOptions.chars.length; i++)\n        encodeBuf[codecOptions.chars.charCodeAt(i)] = i;\n\n    this.encodeBuf = encodeBuf;\n}\n\nSBCSCodec.prototype.encoder = SBCSEncoder;\nSBCSCodec.prototype.decoder = SBCSDecoder;\n\n\nfunction SBCSEncoder(options, codec) {\n    this.encodeBuf = codec.encodeBuf;\n}\n\nSBCSEncoder.prototype.write = function(str) {\n    var buf = new Buffer(str.length);\n    for (var i = 0; i < str.length; i++)\n        buf[i] = this.encodeBuf[str.charCodeAt(i)];\n    \n    return buf;\n}\n\nSBCSEncoder.prototype.end = function() {\n}\n\n\nfunction SBCSDecoder(options, codec) {\n    this.decodeBuf = codec.decodeBuf;\n}\n\nSBCSDecoder.prototype.write = function(buf) {\n    // Strings are immutable in JS -> we use ucs2 buffer to speed up computations.\n    var decodeBuf = this.decodeBuf;\n    var newBuf = new Buffer(buf.length*2);\n    var idx1 = 0, idx2 = 0;\n    for (var i = 0; i < buf.length; i++) {\n        idx1 = buf[i]*2; idx2 = i*2;\n        newBuf[idx2] = decodeBuf[idx1];\n        newBuf[idx2+1] = decodeBuf[idx1+1];\n    }\n    return newBuf.toString('ucs2');\n}\n\nSBCSDecoder.prototype.end = function() {\n}\n"]}