{"version":3,"sources":["dbcs-codec.js"],"names":[],"mappings":"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","file":"dbcs-codec-compiled.js","sourcesContent":["\"use strict\"\n\n// Multibyte codec. In this scheme, a character is represented by 1 or more bytes.\n// Our codec supports UTF-16 surrogates, extensions for GB18030 and unicode sequences.\n// To save memory and loading time, we read table files only when requested.\n\nexports._dbcs = DBCSCodec;\n\nvar UNASSIGNED = -1,\n    GB18030_CODE = -2,\n    SEQ_START  = -10,\n    NODE_START = -1000,\n    UNASSIGNED_NODE = new Array(0x100),\n    DEF_CHAR = -1;\n\nfor (var i = 0; i < 0x100; i++)\n    UNASSIGNED_NODE[i] = UNASSIGNED;\n\n\n// Class DBCSCodec reads and initializes mapping tables.\nfunction DBCSCodec(codecOptions, iconv) {\n    this.encodingName = codecOptions.encodingName;\n    if (!codecOptions)\n        throw new Error(\"DBCS codec is called without the data.\")\n    if (!codecOptions.table)\n        throw new Error(\"Encoding '\" + this.encodingName + \"' has no data.\");\n\n    // Load tables.\n    var mappingTable = codecOptions.table();\n\n\n    // Decode tables: MBCS -> Unicode.\n\n    // decodeTables is a trie, encoded as an array of arrays of integers. Internal arrays are trie nodes and all have len = 256.\n    // Trie root is decodeTables[0].\n    // Values: >=  0 -> unicode character code. can be > 0xFFFF\n    //         == UNASSIGNED -> unknown/unassigned sequence.\n    //         == GB18030_CODE -> this is the end of a GB18030 4-byte sequence.\n    //         <= NODE_START -> index of the next node in our trie to process next byte.\n    //         <= SEQ_START  -> index of the start of a character code sequence, in decodeTableSeq.\n    this.decodeTables = [];\n    this.decodeTables[0] = UNASSIGNED_NODE.slice(0); // Create root node.\n\n    // Sometimes a MBCS char corresponds to a sequence of unicode chars. We store them as arrays of integers here. \n    this.decodeTableSeq = [];\n\n    // Actual mapping tables consist of chunks. Use them to fill up decode tables.\n    for (var i = 0; i < mappingTable.length; i++)\n        this._addDecodeChunk(mappingTable[i]);\n\n    this.defaultCharUnicode = iconv.defaultCharUnicode;\n\n    \n    // Encode tables: Unicode -> DBCS.\n\n    // `encodeTable` is array mapping from unicode char to encoded char. All its values are integers for performance.\n    // Because it can be sparse, it is represented as array of buckets by 256 chars each. Bucket can be null.\n    // Values: >=  0 -> it is a normal char. Write the value (if <=256 then 1 byte, if <=65536 then 2 bytes, etc.).\n    //         == UNASSIGNED -> no conversion found. Output a default char.\n    //         <= SEQ_START  -> it's an index in encodeTableSeq, see below. The character starts a sequence.\n    this.encodeTable = [];\n    \n    // `encodeTableSeq` is used when a sequence of unicode characters is encoded as a single code. We use a tree of\n    // objects where keys correspond to characters in sequence and leafs are the encoded dbcs values. A special DEF_CHAR key\n    // means end of sequence (needed when one sequence is a strict subsequence of another).\n    // Objects are kept separately from encodeTable to increase performance.\n    this.encodeTableSeq = [];\n\n    // Some chars can be decoded, but need not be encoded.\n    var skipEncodeChars = {};\n    if (codecOptions.encodeSkipVals)\n        for (var i = 0; i < codecOptions.encodeSkipVals.length; i++) {\n            var val = codecOptions.encodeSkipVals[i];\n            if (typeof val === 'number')\n                skipEncodeChars[val] = true;\n            else\n                for (var j = val.from; j <= val.to; j++)\n                    skipEncodeChars[j] = true;\n        }\n        \n    // Use decode trie to recursively fill out encode tables.\n    this._fillEncodeTable(0, 0, skipEncodeChars);\n\n    // Add more encoding pairs when needed.\n    if (codecOptions.encodeAdd) {\n        for (var uChar in codecOptions.encodeAdd)\n            if (Object.prototype.hasOwnProperty.call(codecOptions.encodeAdd, uChar))\n                this._setEncodeChar(uChar.charCodeAt(0), codecOptions.encodeAdd[uChar]);\n    }\n\n    this.defCharSB  = this.encodeTable[0][iconv.defaultCharSingleByte.charCodeAt(0)];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = this.encodeTable[0]['?'];\n    if (this.defCharSB === UNASSIGNED) this.defCharSB = \"?\".charCodeAt(0);\n\n\n    // Load & create GB18030 tables when needed.\n    if (typeof codecOptions.gb18030 === 'function') {\n        this.gb18030 = codecOptions.gb18030(); // Load GB18030 ranges.\n\n        // Add GB18030 decode tables.\n        var thirdByteNodeIdx = this.decodeTables.length;\n        var thirdByteNode = this.decodeTables[thirdByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        var fourthByteNodeIdx = this.decodeTables.length;\n        var fourthByteNode = this.decodeTables[fourthByteNodeIdx] = UNASSIGNED_NODE.slice(0);\n\n        for (var i = 0x81; i <= 0xFE; i++) {\n            var secondByteNodeIdx = NODE_START - this.decodeTables[0][i];\n            var secondByteNode = this.decodeTables[secondByteNodeIdx];\n            for (var j = 0x30; j <= 0x39; j++)\n                secondByteNode[j] = NODE_START - thirdByteNodeIdx;\n        }\n        for (var i = 0x81; i <= 0xFE; i++)\n            thirdByteNode[i] = NODE_START - fourthByteNodeIdx;\n        for (var i = 0x30; i <= 0x39; i++)\n            fourthByteNode[i] = GB18030_CODE\n    }        \n}\n\nDBCSCodec.prototype.encoder = DBCSEncoder;\nDBCSCodec.prototype.decoder = DBCSDecoder;\n\n// Decoder helpers\nDBCSCodec.prototype._getDecodeTrieNode = function(addr) {\n    var bytes = [];\n    for (; addr > 0; addr >>= 8)\n        bytes.push(addr & 0xFF);\n    if (bytes.length == 0)\n        bytes.push(0);\n\n    var node = this.decodeTables[0];\n    for (var i = bytes.length-1; i > 0; i--) { // Traverse nodes deeper into the trie.\n        var val = node[bytes[i]];\n\n        if (val == UNASSIGNED) { // Create new node.\n            node[bytes[i]] = NODE_START - this.decodeTables.length;\n            this.decodeTables.push(node = UNASSIGNED_NODE.slice(0));\n        }\n        else if (val <= NODE_START) { // Existing node.\n            node = this.decodeTables[NODE_START - val];\n        }\n        else\n            throw new Error(\"Overwrite byte in \" + this.encodingName + \", addr: \" + addr.toString(16));\n    }\n    return node;\n}\n\n\nDBCSCodec.prototype._addDecodeChunk = function(chunk) {\n    // First element of chunk is the hex mbcs code where we start.\n    var curAddr = parseInt(chunk[0], 16);\n\n    // Choose the decoding node where we'll write our chars.\n    var writeTable = this._getDecodeTrieNode(curAddr);\n    curAddr = curAddr & 0xFF;\n\n    // Write all other elements of the chunk to the table.\n    for (var k = 1; k < chunk.length; k++) {\n        var part = chunk[k];\n        if (typeof part === \"string\") { // String, write as-is.\n            for (var l = 0; l < part.length;) {\n                var code = part.charCodeAt(l++);\n                if (0xD800 <= code && code < 0xDC00) { // Decode surrogate\n                    var codeTrail = part.charCodeAt(l++);\n                    if (0xDC00 <= codeTrail && codeTrail < 0xE000)\n                        writeTable[curAddr++] = 0x10000 + (code - 0xD800) * 0x400 + (codeTrail - 0xDC00);\n                    else\n                        throw new Error(\"Incorrect surrogate pair in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n                }\n                else if (0x0FF0 < code && code <= 0x0FFF) { // Character sequence (our own encoding used)\n                    var len = 0xFFF - code + 2;\n                    var seq = [];\n                    for (var m = 0; m < len; m++)\n                        seq.push(part.charCodeAt(l++)); // Simple variation: don't support surrogates or subsequences in seq.\n\n                    writeTable[curAddr++] = SEQ_START - this.decodeTableSeq.length;\n                    this.decodeTableSeq.push(seq);\n                }\n                else\n                    writeTable[curAddr++] = code; // Basic char\n            }\n        } \n        else if (typeof part === \"number\") { // Integer, meaning increasing sequence starting with prev character.\n            var charCode = writeTable[curAddr - 1] + 1;\n            for (var l = 0; l < part; l++)\n                writeTable[curAddr++] = charCode++;\n        }\n        else\n            throw new Error(\"Incorrect type '\" + typeof part + \"' given in \"  + this.encodingName + \" at chunk \" + chunk[0]);\n    }\n    if (curAddr > 0xFF)\n        throw new Error(\"Incorrect chunk in \"  + this.encodingName + \" at addr \" + chunk[0] + \": too long\" + curAddr);\n}\n\n// Encoder helpers\nDBCSCodec.prototype._getEncodeBucket = function(uCode) {\n    var high = uCode >> 8; // This could be > 0xFF because of astral characters.\n    if (this.encodeTable[high] === undefined)\n        this.encodeTable[high] = UNASSIGNED_NODE.slice(0); // Create bucket on demand.\n    return this.encodeTable[high];\n}\n\nDBCSCodec.prototype._setEncodeChar = function(uCode, dbcsCode) {\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n    if (bucket[low] <= SEQ_START)\n        this.encodeTableSeq[SEQ_START-bucket[low]][DEF_CHAR] = dbcsCode; // There's already a sequence, set a single-char subsequence of it.\n    else if (bucket[low] == UNASSIGNED)\n        bucket[low] = dbcsCode;\n}\n\nDBCSCodec.prototype._setEncodeSequence = function(seq, dbcsCode) {\n    \n    // Get the root of character tree according to first character of the sequence.\n    var uCode = seq[0];\n    var bucket = this._getEncodeBucket(uCode);\n    var low = uCode & 0xFF;\n\n    var node;\n    if (bucket[low] <= SEQ_START) {\n        // There's already a sequence with  - use it.\n        node = this.encodeTableSeq[SEQ_START-bucket[low]];\n    }\n    else {\n        // There was no sequence object - allocate a new one.\n        node = {};\n        if (bucket[low] !== UNASSIGNED) node[DEF_CHAR] = bucket[low]; // If a char was set before - make it a single-char subsequence.\n        bucket[low] = SEQ_START - this.encodeTableSeq.length;\n        this.encodeTableSeq.push(node);\n    }\n\n    // Traverse the character tree, allocating new nodes as needed.\n    for (var j = 1; j < seq.length-1; j++) {\n        var oldVal = node[uCode];\n        if (typeof oldVal === 'object')\n            node = oldVal;\n        else {\n            node = node[uCode] = {}\n            if (oldVal !== undefined)\n                node[DEF_CHAR] = oldVal\n        }\n    }\n\n    // Set the leaf to given dbcsCode.\n    uCode = seq[seq.length-1];\n    node[uCode] = dbcsCode;\n}\n\nDBCSCodec.prototype._fillEncodeTable = function(nodeIdx, prefix, skipEncodeChars) {\n    var node = this.decodeTables[nodeIdx];\n    for (var i = 0; i < 0x100; i++) {\n        var uCode = node[i];\n        var mbCode = prefix + i;\n        if (skipEncodeChars[mbCode])\n            continue;\n\n        if (uCode >= 0)\n            this._setEncodeChar(uCode, mbCode);\n        else if (uCode <= NODE_START)\n            this._fillEncodeTable(NODE_START - uCode, mbCode << 8, skipEncodeChars);\n        else if (uCode <= SEQ_START)\n            this._setEncodeSequence(this.decodeTableSeq[SEQ_START - uCode], mbCode);\n    }\n}\n\n\n\n// == Encoder ==================================================================\n\nfunction DBCSEncoder(options, codec) {\n    // Encoder state\n    this.leadSurrogate = -1;\n    this.seqObj = undefined;\n    \n    // Static data\n    this.encodeTable = codec.encodeTable;\n    this.encodeTableSeq = codec.encodeTableSeq;\n    this.defaultCharSingleByte = codec.defCharSB;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSEncoder.prototype.write = function(str) {\n    var newBuf = new Buffer(str.length * (this.gb18030 ? 4 : 3)), \n        leadSurrogate = this.leadSurrogate,\n        seqObj = this.seqObj, nextChar = -1,\n        i = 0, j = 0;\n\n    while (true) {\n        // 0. Get next character.\n        if (nextChar === -1) {\n            if (i == str.length) break;\n            var uCode = str.charCodeAt(i++);\n        }\n        else {\n            var uCode = nextChar;\n            nextChar = -1;    \n        }\n\n        // 1. Handle surrogates.\n        if (0xD800 <= uCode && uCode < 0xE000) { // Char is one of surrogates.\n            if (uCode < 0xDC00) { // We've got lead surrogate.\n                if (leadSurrogate === -1) {\n                    leadSurrogate = uCode;\n                    continue;\n                } else {\n                    leadSurrogate = uCode;\n                    // Double lead surrogate found.\n                    uCode = UNASSIGNED;\n                }\n            } else { // We've got trail surrogate.\n                if (leadSurrogate !== -1) {\n                    uCode = 0x10000 + (leadSurrogate - 0xD800) * 0x400 + (uCode - 0xDC00);\n                    leadSurrogate = -1;\n                } else {\n                    // Incomplete surrogate pair - only trail surrogate found.\n                    uCode = UNASSIGNED;\n                }\n                \n            }\n        }\n        else if (leadSurrogate !== -1) {\n            // Incomplete surrogate pair - only lead surrogate found.\n            nextChar = uCode; uCode = UNASSIGNED; // Write an error, then current char.\n            leadSurrogate = -1;\n        }\n\n        // 2. Convert uCode character.\n        var dbcsCode = UNASSIGNED;\n        if (seqObj !== undefined && uCode != UNASSIGNED) { // We are in the middle of the sequence\n            var resCode = seqObj[uCode];\n            if (typeof resCode === 'object') { // Sequence continues.\n                seqObj = resCode;\n                continue;\n\n            } else if (typeof resCode == 'number') { // Sequence finished. Write it.\n                dbcsCode = resCode;\n\n            } else if (resCode == undefined) { // Current character is not part of the sequence.\n\n                // Try default character for this sequence\n                resCode = seqObj[DEF_CHAR];\n                if (resCode !== undefined) {\n                    dbcsCode = resCode; // Found. Write it.\n                    nextChar = uCode; // Current character will be written too in the next iteration.\n\n                } else {\n                    // TODO: What if we have no default? (resCode == undefined)\n                    // Then, we should write first char of the sequence as-is and try the rest recursively.\n                    // Didn't do it for now because no encoding has this situation yet.\n                    // Currently, just skip the sequence and write current char.\n                }\n            }\n            seqObj = undefined;\n        }\n        else if (uCode >= 0) {  // Regular character\n            var subtable = this.encodeTable[uCode >> 8];\n            if (subtable !== undefined)\n                dbcsCode = subtable[uCode & 0xFF];\n            \n            if (dbcsCode <= SEQ_START) { // Sequence start\n                seqObj = this.encodeTableSeq[SEQ_START-dbcsCode];\n                continue;\n            }\n\n            if (dbcsCode == UNASSIGNED && this.gb18030) {\n                // Use GB18030 algorithm to find character(s) to write.\n                var idx = findIdx(this.gb18030.uChars, uCode);\n                if (idx != -1) {\n                    var dbcsCode = this.gb18030.gbChars[idx] + (uCode - this.gb18030.uChars[idx]);\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 12600); dbcsCode = dbcsCode % 12600;\n                    newBuf[j++] = 0x30 + Math.floor(dbcsCode / 1260); dbcsCode = dbcsCode % 1260;\n                    newBuf[j++] = 0x81 + Math.floor(dbcsCode / 10); dbcsCode = dbcsCode % 10;\n                    newBuf[j++] = 0x30 + dbcsCode;\n                    continue;\n                }\n            }\n        }\n\n        // 3. Write dbcsCode character.\n        if (dbcsCode === UNASSIGNED)\n            dbcsCode = this.defaultCharSingleByte;\n        \n        if (dbcsCode < 0x100) {\n            newBuf[j++] = dbcsCode;\n        }\n        else if (dbcsCode < 0x10000) {\n            newBuf[j++] = dbcsCode >> 8;   // high byte\n            newBuf[j++] = dbcsCode & 0xFF; // low byte\n        }\n        else {\n            newBuf[j++] = dbcsCode >> 16;\n            newBuf[j++] = (dbcsCode >> 8) & 0xFF;\n            newBuf[j++] = dbcsCode & 0xFF;\n        }\n    }\n\n    this.seqObj = seqObj;\n    this.leadSurrogate = leadSurrogate;\n    return newBuf.slice(0, j);\n}\n\nDBCSEncoder.prototype.end = function() {\n    if (this.leadSurrogate === -1 && this.seqObj === undefined)\n        return; // All clean. Most often case.\n\n    var newBuf = new Buffer(10), j = 0;\n\n    if (this.seqObj) { // We're in the sequence.\n        var dbcsCode = this.seqObj[DEF_CHAR];\n        if (dbcsCode !== undefined) { // Write beginning of the sequence.\n            if (dbcsCode < 0x100) {\n                newBuf[j++] = dbcsCode;\n            }\n            else {\n                newBuf[j++] = dbcsCode >> 8;   // high byte\n                newBuf[j++] = dbcsCode & 0xFF; // low byte\n            }\n        } else {\n            // See todo above.\n        }\n        this.seqObj = undefined;\n    }\n\n    if (this.leadSurrogate !== -1) {\n        // Incomplete surrogate pair - only lead surrogate found.\n        newBuf[j++] = this.defaultCharSingleByte;\n        this.leadSurrogate = -1;\n    }\n    \n    return newBuf.slice(0, j);\n}\n\n// Export for testing\nDBCSEncoder.prototype.findIdx = findIdx;\n\n\n// == Decoder ==================================================================\n\nfunction DBCSDecoder(options, codec) {\n    // Decoder state\n    this.nodeIdx = 0;\n    this.prevBuf = new Buffer(0);\n\n    // Static data\n    this.decodeTables = codec.decodeTables;\n    this.decodeTableSeq = codec.decodeTableSeq;\n    this.defaultCharUnicode = codec.defaultCharUnicode;\n    this.gb18030 = codec.gb18030;\n}\n\nDBCSDecoder.prototype.write = function(buf) {\n    var newBuf = new Buffer(buf.length*2),\n        nodeIdx = this.nodeIdx, \n        prevBuf = this.prevBuf, prevBufOffset = this.prevBuf.length,\n        seqStart = -this.prevBuf.length, // idx of the start of current parsed sequence.\n        uCode;\n\n    if (prevBufOffset > 0) // Make prev buf overlap a little to make it easier to slice later.\n        prevBuf = Buffer.concat([prevBuf, buf.slice(0, 10)]);\n    \n    for (var i = 0, j = 0; i < buf.length; i++) {\n        var curByte = (i >= 0) ? buf[i] : prevBuf[i + prevBufOffset];\n\n        // Lookup in current trie node.\n        var uCode = this.decodeTables[nodeIdx][curByte];\n\n        if (uCode >= 0) { \n            // Normal character, just use it.\n        }\n        else if (uCode === UNASSIGNED) { // Unknown char.\n            // TODO: Callback with seq.\n            //var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            i = seqStart; // Try to parse again, after skipping first byte of the sequence ('i' will be incremented by 'for' cycle).\n            uCode = this.defaultCharUnicode.charCodeAt(0);\n        }\n        else if (uCode === GB18030_CODE) {\n            var curSeq = (seqStart >= 0) ? buf.slice(seqStart, i+1) : prevBuf.slice(seqStart + prevBufOffset, i+1 + prevBufOffset);\n            var ptr = (curSeq[0]-0x81)*12600 + (curSeq[1]-0x30)*1260 + (curSeq[2]-0x81)*10 + (curSeq[3]-0x30);\n            var idx = findIdx(this.gb18030.gbChars, ptr);\n            uCode = this.gb18030.uChars[idx] + ptr - this.gb18030.gbChars[idx];\n        }\n        else if (uCode <= NODE_START) { // Go to next trie node.\n            nodeIdx = NODE_START - uCode;\n            continue;\n        }\n        else if (uCode <= SEQ_START) { // Output a sequence of chars.\n            var seq = this.decodeTableSeq[SEQ_START - uCode];\n            for (var k = 0; k < seq.length - 1; k++) {\n                uCode = seq[k];\n                newBuf[j++] = uCode & 0xFF;\n                newBuf[j++] = uCode >> 8;\n            }\n            uCode = seq[seq.length-1];\n        }\n        else\n            throw new Error(\"iconv-lite internal error: invalid decoding table value \" + uCode + \" at \" + nodeIdx + \"/\" + curByte);\n\n        // Write the character to buffer, handling higher planes using surrogate pair.\n        if (uCode > 0xFFFF) { \n            uCode -= 0x10000;\n            var uCodeLead = 0xD800 + Math.floor(uCode / 0x400);\n            newBuf[j++] = uCodeLead & 0xFF;\n            newBuf[j++] = uCodeLead >> 8;\n\n            uCode = 0xDC00 + uCode % 0x400;\n        }\n        newBuf[j++] = uCode & 0xFF;\n        newBuf[j++] = uCode >> 8;\n\n        // Reset trie node.\n        nodeIdx = 0; seqStart = i+1;\n    }\n\n    this.nodeIdx = nodeIdx;\n    this.prevBuf = (seqStart >= 0) ? buf.slice(seqStart) : prevBuf.slice(seqStart + prevBufOffset);\n    return newBuf.slice(0, j).toString('ucs2');\n}\n\nDBCSDecoder.prototype.end = function() {\n    var ret = '';\n\n    // Try to parse all remaining chars.\n    while (this.prevBuf.length > 0) {\n        // Skip 1 character in the buffer.\n        ret += this.defaultCharUnicode;\n        var buf = this.prevBuf.slice(1);\n\n        // Parse remaining as usual.\n        this.prevBuf = new Buffer(0);\n        this.nodeIdx = 0;\n        if (buf.length > 0)\n            ret += this.write(buf);\n    }\n\n    this.nodeIdx = 0;\n    return ret;\n}\n\n// Binary search for GB18030. Returns largest i such that table[i] <= val.\nfunction findIdx(table, val) {\n    if (table[0] > val)\n        return -1;\n\n    var l = 0, r = table.length;\n    while (l < r-1) { // always table[l] <= val < table[r]\n        var mid = l + Math.floor((r-l+1)/2);\n        if (table[mid] <= val)\n            l = mid;\n        else\n            r = mid;\n    }\n    return l;\n}\n\n"]}