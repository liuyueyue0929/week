{"version":3,"sources":["isHiddenWithinTree-compiled.js"],"names":[],"mappings":"AAAA,OAAO,CAAC,YAAD,EAAe;;AAEtB;AAFO,CAAP,EAGG,UAAU,MAAV,EAAkB;AACpB;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,QAAO,UAAU,IAAV,EAAgB,EAAhB,EAAoB;;AAE1B;AACA;AACA,SAAO,MAAM,IAAb;;AAEA;AACA,SAAO,KAAK,KAAL,CAAW,OAAX,KAAuB,MAAvB,IAAiC,KAAK,KAAL,CAAW,OAAX,KAAuB,EAAvB;;AAExC;AACA;AACA;AACA;AACA,SAAO,QAAP,CAAgB,KAAK,aAArB,EAAoC,IAApC,CANwC,IAMK,OAAO,GAAP,CAAW,IAAX,EAAiB,SAAjB,MAAgC,MAN7E;AAOA,EAdD;AAeA,CA7BD;;AA+BA","file":"isHiddenWithinTree-compiled-compiled.js","sourcesContent":["define([\"../../core\", \"../../selector\"\n\n// css is assumed\n], function (jQuery) {\n\t\"use strict\";\n\n\t// isHiddenWithinTree reports if an element has a non-\"none\" display style (inline and/or\n\t// through the CSS cascade), which is useful in deciding whether or not to make it visible.\n\t// It differs from the :hidden selector (jQuery.expr.pseudos.hidden) in two important ways:\n\t// * A hidden ancestor does not force an element to be classified as hidden.\n\t// * Being disconnected from the document does not force an element to be classified as hidden.\n\t// These differences improve the behavior of .toggle() et al. when applied to elements that are\n\t// detached or contained within hidden ancestors (gh-2404, gh-2863).\n\n\treturn function (elem, el) {\n\n\t\t// isHiddenWithinTree might be called from jQuery#filter function;\n\t\t// in that case, element will be second argument\n\t\telem = el || elem;\n\n\t\t// Inline style trumps all\n\t\treturn elem.style.display === \"none\" || elem.style.display === \"\" &&\n\n\t\t// Otherwise, check computed style\n\t\t// Support: Firefox <=43 - 45\n\t\t// Disconnected elements can have computed display: none, so first confirm that elem is\n\t\t// in the document.\n\t\tjQuery.contains(elem.ownerDocument, elem) && jQuery.css(elem, \"display\") === \"none\";\n\t};\n});\n\n//# sourceMappingURL=isHiddenWithinTree-compiled.js.map"]}